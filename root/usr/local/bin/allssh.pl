#!/usr/bin/perl

#############################################################################
# $Id: //depot/manatee/main/tools/bin/allssh.pl#28 $
#############################################################################
# This program allows a command to be run over all nodes in a range
# or in a cluster
#
# Do not edit this file without using perforce!!!
#############################################################################

use Getopt::Long;			        # for getopts()
use strict;					# prevent typos
use FindBin '$Bin';				# locate the libraries
BEGIN { unshift(@INC,"$Bin/../lib", "/home/seco/tools/lib") }

use Seco::FnSeco;
use Seco::Allssh;

my( $arg, @nodes, @nodes2, $node,  $pwd, $cmd) = ();
my( $line, $errors, $error, $allssh, $hostname, @sshargs) = ();

$| =1;
#############################################################################
# Get arguments
#############################################################################
use vars '%argv';
Getopt::Long::config("require_order");
Getopt::Long::config("no_ignore_case");

if(!(GetOptions(\%argv,"p=s","h","n","l","L","s","B","b|binary=s","c|cluster=s","r|range=s","x|exclude=s","R|Range=s","v|verbose","f|format=s","m|maxflight=s","ping=s","uid=s","z|maxtime=i","Q|onlyerrors", "o|opts=s"))
     || $argv{"h"} || (!$argv{"n"} && !$argv{"l"} && !$argv{"L"} && $#ARGV < 0)) {
        print STDERR "Usage: $0 [-h] [-c <cluster>] [-r <range>] [-x <nodes>] [-R <range>] [-l] [-p] [-n] <command>\n";
	print STDERR "\tExecute the command once for each node in the cluster\n";
	print STDERR "\tsubstituting '{}' for the name of the node\n";
	print STDERR "\t-h displays this help information\n";
	print STDERR "\t-c specifies a cluster to operate on.  May be of the\n";
	print STDERR "\t   form cluster or cluster:TYPE[RANGE] (i.e. sc3 or sc3:CLUSTER or sc3:CLUSTER[0-9].)\n";
	print STDERR "\t-n only display count of nodes.\n";
	print STDERR "\t-r specifies a range to be operated on.\n";
	print STDERR "\t-x excludes nodes.\n";
	print STDERR "\t-R secondary range to iterate over.\n";
	print STDERR "\t-l only list nodes (or use -L for better compression)\n";
	print STDERR "\t-s don't delete log files for hosts that failed.\n";
	print STDERR "\t-m specify max # of open ssh's.\n";
	print STDERR "\t-v Allssh.pm->verbose(1).\n";
	print STDERR "\t-f perl sprintf format code, i.e. %02s.  Affects {i} and {mme}.\n";
	print STDERR "\t-p specify how long to pause between connections.\n";
	print STDERR "\t-ping (port number, or ICMP) - ping first\n";
        print STDERR "\t-uid \$username (must be ran as root)\n";
        print STDERR "\t-b run in binary spawn mode (for rsync)\n";
	print STDERR "\t-B with -b, only use first source once\n";
        print STDERR "\t-z max time to allow child process to run\n";
        print STDERR "\t-Q print only errors, not successes\n";
	print STDERR "\t-o Supply single letter switches to ssh invocation\n";
	print STDERR "\t   (-o t24 adds: -t -2 -4 to ssh execution)\n";
        exit;
}


#############################################################################
# Build up the node list
#############################################################################

@nodes = &standardNodesParser($argv{'c'},$argv{'r'},$argv{'x'});

if ($argv{'R'})
{
	# Build up secondary range list
	@nodes2 = &standardNodesParser('',$argv{'R'},'');
}

### Verfiy that we have nodes
if( $#nodes <0)
{
	die "ERROR: No nodes specified";
}

### Verify that the secondary range is *at least* as long as the primary
if (($#nodes2 > -1) && ($#nodes2 < $#nodes))
{
	 print "WARNING: secondary range is shorter than the primary range - cycling through.\n"
}

### if -n, then print out node count
if( $argv{"n"})
{
        my($count) = $#nodes+1;
	print "$count nodes specified.\n";
	exit;
}

### if -l, then print out nodes
if( $argv{"l"})
{
	my %nodes = ();
	foreach $node (@nodes)
        {
		$nodes{$node} = 1;
	}
 	print &CompressRange( %nodes);
	print "\n";
	
	exit;
}

### if -L, then print out nodes with more compression (and quotes)
if( $argv{"L"})
{
	my %nodes = ();
	foreach $node (@nodes)
        {
		$nodes{$node} = 1;
	}
        print "\"";
 	print &CompressRangeBetter( %nodes);
	print "\"\n";
	
	exit;
}



### Print out all nodes up front
if (! $argv{"Q"}) {
  print STDERR "Nodes:";
  foreach $node (@nodes)
  {
  	print STDERR " $node";
  }
  print STDERR "\n";
  print STDERR $#nodes+1, " nodes specified\n";
}

# Set up the extra ssh args, if we're passing any
if ($argv{o}) {
	@sshargs = map { "-$_" } split(//, $argv{o});
}

$|= 1;

# Get current NFS path working directory
$pwd = "/net/" . `/bin/hostname ; /bin/pwd`;
$pwd =~ s/[\r\n]//g;


### Build up command
foreach $arg (@ARGV) {
    $cmd .= "$arg ";
}
$cmd =~ s/{pwd}/$pwd/g;
$cmd =~ s/\\{\\}/{}/g;
chomp($cmd);
print STDERR "Command: $cmd\n" unless ($argv{"Q"});

### Iterate over all the nodes
$allssh = new Seco::Allssh;

###  set uid if requested

if ($argv{"uid"}) {
  if ($< =~ m/0/) {
     my  ($name,$passwd,$uid,$gid)  = getpwnam($argv{"uid"});
     if ($name =~ m/./) {
        $allssh->setuid($uid);
        print STDERR "now running as user $argv{uid} (user $uid)\n" if ($argv{"v"});
     } else {
        die "Could not locate username $argv{uid} to set uid to\n";
     }
  } else {
     print STDERR "must run as root, not user $<, to specify -uid \$user\n";
     exit 1;
  }
}


$SIG{'INT'} = sub {
  my ($i);
  foreach $i ( @{$allssh->outfiles()})  {
      my ($host, $file) = @{$i} ;
      unlink($file);
  }
  exit;
};


###
### pdm's "Multi-phasic" rsync mod
###

#$hostname = `/bin/hostname`; chomp $hostname;
#if ($argv{b}) { $allssh->source("$hostname"); }

if ($argv{B}) {
  $allssh->sourceonce(1);
}

if ($argv{b}) {
	my ($source, $rsync) = split(/,/, $argv{b}, 2);

	if ( (!defined($rsync)) || ($rsync eq "") ) {
		($rsync = $source) =~ s/.*(::)/$1/;
	}

	# Prime the queue with the admin host (or whatever)
	$allssh->source("$source");
	# Provide the module to pull from for other hosts
	$allssh->rsync("$rsync");
}

###
### End Multi-phasic
###

$allssh->pingfirst($argv{ping}||0);
$allssh->maxflight($argv{m} || 150);
$allssh->verbose($argv{v});
$allssh->pause($argv{p} || 0);
$allssh->format($argv{f});
$allssh->cleanup(0);
$allssh->maxtime($argv{"z"}||0);
$allssh->nodes2(join(",",@nodes2));
$allssh->command(join(",",@nodes),$cmd, @sshargs);
my ($i);
my ($aref);

$aref = $allssh->downhosts();
if ($aref) {
  foreach (@{$aref}) {
    print "ERROR: $_ down\n";
    $errors++;
  }
}


$aref = $allssh->outfiles();
unless ($aref) {
  warn "ERROR: No nodes completed successfully.\n";
  exit 1;
}

foreach $i ( @{$allssh->outfiles()})  {
    my ($host, $file) = @{$i} ;
#    print "$host: $file\n";
    $error = $allssh->{exitcodes}{$host};
    if (($error) || (! $argv{"Q"})) {
      if (!(open(FILE,"$file"))) {
         warn "ERROR: could not open file $file\n";
         $errors++;
      } else {
         while(defined ($line=<FILE>)) {
           print "$host: $line";
         }
         close FILE;
      }
    }
    if ($error) {
         print "$host: exit status $error\n";
         unlink($file) unless ($argv{"s"});
         $errors++;
    } else { 
         unlink($file);
    }
}

exit 1 if ($errors);
